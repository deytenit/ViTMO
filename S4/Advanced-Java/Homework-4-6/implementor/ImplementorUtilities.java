package info.kgeorgiy.ja.eremin.implementor;

import static info.kgeorgiy.ja.eremin.implementor.ImplementorKeywords.*;

import info.kgeorgiy.java.advanced.implementor.ImplerException;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLClassLoader;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.jar.Attributes;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;
import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;

public class ImplementorUtilities {
  /**
   * Returns name for generated <a href="#impl-source">impl-source</a>.
   *
   * <p>Behavior varies based on {@code canonical} option:
   *
   * <ul>
   *   <li>True: {@code package.name.class-simple-nameImpl}
   *   <li>False: {@code class-simple-nameImpl}
   * </ul>
   *
   * @param token {@link Class} for which <i>'Impl'-ended</i> name should be generated.
   * @param canonical Decides whether resulting name contains {@link Class#getPackageName() package
   *     name}.
   * @return Provided Class name with <i>Impl</i> suffix.
   */
  static String getImplName(final Class<?> token, boolean canonical) {
    return (canonical ? token.getPackageName() + "." : EMPTY) + token.getSimpleName() + IMPL;
  }

  /**
   * Returns {@link Path} of {@link #getImplName(Class, boolean)} relative to {@code root}.
   *
   * <p>Extension of file is deducted from {@code isClass} option:
   *
   * <ul>
   *   <li>True: {@code /.../class-impl-name.class}
   *   <li>False: {@code /.../class-impl-name.java}
   * </ul>
   *
   * @param token {@link Class} for which <i>'Impl'-ended</i> path should be generated.
   * @param root Package root of generated <a href="#impl-source">impl-source</a>.
   * @param isClass Decides whether resulting path targets <i>java-source</i> or
   *     <i>class-bytecode</i>.
   * @return Path to generated <a href="#impl-source">impl-source</a> file.
   */
  static Path getImplPath(final Class<?> token, final Path root, boolean isClass) {
    return Path.of(
        root.toString(),
        getImplName(token, true).replace(".", File.separator) + (isClass ? ".class" : ".java"));
  }

  /**
   * Tabulates the whole string with <i>tabs</i>.
   *
   * <p><i>tab</i> is just {@link ImplementorKeywords#SPACE} repeated {@link
   * ImplementorKeywords#TABSTOP} times.
   *
   * <p>Replaces each <i>new-line</i> with <i>{@link ImplementorKeywords#NEW_LINE} + tab</i>, trims
   * latest <i>tab</i> if resulting String ends with it.
   *
   * <p>Resulted String then concatenated to another <i>tab</i>, so the first line would be indented
   * too.
   *
   * @param str {@link String} to tabulate.
   * @param amount Number of <i>tabs</i> prefixed before each line.
   * @return the same String, but tabulated.
   */
  static String tabulate(final String str, final int amount) {
    String tab = SPACE.repeat(amount * TABSTOP);

    return tab + str.replaceAll("\\R", NEW_LINE + tab).replaceFirst(tab + "$", EMPTY);
  }

  /**
   * Loads the class with the specified binary name.
   *
   * <p>It is invoked to resolve class references, as creating {@code target}, it's allowing {@link
   * Implementor#implement(Class, Path)} to work through them.
   *
   * @param className {@link String} is name of class that should be loaded.
   * @return {@link Class} is the resulting {@code reflect} object.
   * @throws ImplerException If class loading error occurs.
   * @see ClassLoader
   * @see URLClassLoader
   */
  static Class<?> loadClass(final String className) throws ImplerException {
    try (URLClassLoader loader = new URLClassLoader(new URL[] {CWD.toUri().toURL()})) {
      return loader.loadClass(className);
    } catch (final IOException | SecurityException err) {
      throw new ImplerException(
          "Cannot create ClassLoader from specified root. " + err.getMessage());
    } catch (final ClassNotFoundException err) {
      throw new ImplerException("Provided interface was not found. " + err.getMessage());
    }
  }

  /**
   * Compiles <a href="#impl-source">impl-source</a> of the specified interface to <a
   * href="#impl-class">impl-class</a>.
   *
   * <p>Compilation of the java source file that was generated by {@link
   * Implementor#implement(Class, Path)} method, relative to code source of the interface it was
   * implementing.
   *
   * <p>Resulting <a href="#impl-class">impl-class</a> will be located just near the <a
   * href="#impl-source">impl-source</a>.
   *
   * <p>Resulting <a href="#impl-class">impl-class</a> is eligible to be used as a java Jar content,
   * see {@link Implementor#implementJar(Class, Path)}.
   *
   * <p>Using {@link StandardCharsets#UTF_8} as {@link JavaCompiler} encoding.
   *
   * <p>{@link java.security.ProtectionDomain}'s {@link java.security.CodeSource CodeSource} of the
   * specified interface is being used as JavaCompiler classpath.
   *
   * @param token {@link Class} for which <a href="#impl-source">impl-source</a> compilation is
   *     performed.
   * @param root {@link Path} is root relative to which <a href="#impl-source">impl-source</a> is
   *     located.
   * @throws ImplerException If an error during compilation occurs.
   */
  static void compile(final Class<?> token, final Path root) throws ImplerException {
    final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
    if (compiler == null) {
      throw new ImplerException("Could not find java compiler, include tools.jar to classpath.");
    }

    String classpath;
    try {
      classpath =
          Paths.get(token.getProtectionDomain().getCodeSource().getLocation().toURI()).toString();
    } catch (final URISyntaxException e) {
      throw new ImplerException("Cannot obtain impl-class classpath.", e);
    }

    final String sourcePath = getImplPath(token, root, false).toString();
    final String[] args =
        new String[] {sourcePath, "-cp", classpath, "-encoding", StandardCharsets.UTF_8.name()};
    final int exitCode = compiler.run(null, null, null, args);

    if (exitCode != 0) {
      throw new IllegalArgumentException(
          String.format("Compiler returned exit code: %d.", exitCode));
    }
  }

  /**
   * Makes Jar file out of <a href="#impl-class">impl-class</a>, and writes it to the path
   * specified.
   *
   * <p>Being run after <a href="#impl-source">impl-source</a> {@link Implementor#implement(Class,
   * Path) generation} and {@link #compile(Class, Path) it's compilation}. Takes <a
   * href="#impl-class">impl-class</a> and packs in into a Jar file.
   *
   * <p><b>Manifest</b> of the resulting Jar is being:
   *
   * <ul>
   *   <li>{@link Attributes.Name#MANIFEST_VERSION Manifest-Version} = 1.0
   *   <li>{@link Attributes.Name#MAIN_CLASS Main-Class} = (binary name of the <a
   *       href="#impl-class">impl-class</a>)
   * </ul>
   *
   * @param token {@link Class} of <a href="#impl-class">impl-class</a> that will be packed inside
   *     Jar.
   * @param root {@link Path} is root relative to which <a href="#impl-class">impl-class</a> is
   *     located.
   * @param jarFile {@link Path} is the location of the newly made Jar.
   * @throws ImplerException If an error occurs during Jar creation.
   */
  static void makeJar(final Class<?> token, final Path root, final Path jarFile)
      throws ImplerException {
    Manifest manifest = new Manifest();

    manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
    // NOTE: Should I?
    manifest.getMainAttributes().put(Attributes.Name.MAIN_CLASS, getImplName(token, true));

    String classFile = getImplPath(token, Path.of(""), true).toString();

    try (JarOutputStream out =
        new JarOutputStream(new FileOutputStream(jarFile.toString()), manifest)) {
      JarEntry entry = new JarEntry(classFile.replace("\\", "/"));
      out.putNextEntry(entry);

      try {
        Files.copy(Path.of(root.toString(), classFile), out);
      } catch (final IOException | SecurityException err) {
        throw new ImplerException("Error while writing generated impl-source to jar.");
      }
    } catch (final IOException | SecurityException err) {
      throw new ImplerException("Cannot create impl-jar file.");
    }
  }
}
